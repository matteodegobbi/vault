#automata 
# LISTA
## DFAs
Def of DFA
Extension of transition function for DFAs
Language recognized by DFA
## NFAs
Def of NFA
Extension of transition function for NFAs
Language recognized by NFA
Subset construction definition
Lazy eval explanation
Subset construction to transform NFA into DFA with proof of correctness
Equivalence DFAs and NFAs with proof 
Exponential growth of state set with subset construction NO PROOF, only statement
Partial DFA
## eps-NFAs
Def of eps-NFA
ECLOSE definition
Extension of transition function for eps-NFAs
Language recognized by eps-NFA
Conversion?????????
Equivalence forse no proof??????
## regex
Operations on languages
Regex inductive definition,operator precedence
DFA to regex with state elimination, exercises and proof
Regex to eps-NFA with proof 
Properties of regex (forse da saltare non c'e' nel syllabus)
## Reg languages properties
Pumping lemma for Reg, proof and exercises
Closure properties (including proofs) of Reg wrt: 
    - union
    - kleene
    - complement
    - intersection (also intersect automaton)
    - set difference
    - reverse
    - homomorphism (only statement no proof)
Complexity of conversions, just knowing polynomial or exponential time
Decision problems (only usage of algos no proof):
    - Emptiness test
    - Membership test
    - State equivalence algorithm (and def of equivalent states)
    - Equivalence between 2 Reg languages
    - DFA minimization
## CFGs
Def of CFG
Def of rewrite, derivation in one step
Def of reflexive and transitive closure of rewrite
Def of lm/rm derivations
Language generated by a CFG G
Sentential form
Derivation composition
Derivation factorization
Parse Tree definition and yield
Equivalence of parse trees with derivations for terminal strings (no proofs) 
Relation between parse trees and derivation (1 to many and many to 1)
Ambiguity of CFG
1 to 1 relation of lm derivation with parse tree and consequences
Forse Inherent Ambiguity????
Regex to CFG conversion
FA to CFG conversion
## PDAs
Def of PDA, delta, graphical repr
Def of ID, moves and computations  for a PDA
Properties of computation (unaffected by added/removed tail or adding to bottom of stack)
Language accepted by final state
Language accepted by empty stack
Conversion from empty stack to final states with proof
Conversion from final state to empty stack with proof
CFG to PDA statement and construction, no proof
PDA to CFG statement only, no proof
## CFL properties 1
Def of reachable, generating, useful symbols
Elimination of useless symbols
Algorithm to compute generating symbols
Algorithm to compute reachable symbols
Algorithm for nullable variables
Algorithm for elimination of epsilon productions
Algorithm for elimination of unary productions (and unary pair def)
CFG simplication with correct order of eliminations
Chomsky normal form
Conversion of CFG to CNF by simplification followed by decomposing productions
## CFL properties 2 
Pumping lemma for CFLs with proof
Consequences of pumping lemma: counting more than 2 seq, crossing pairs, copie
Closure properties:
    - substitution
    - union
    - concatenation
    - Kleene and + (meaning 1 or more) operator 
    - homomorphism
    - reverse
    - intersection with a reg language (and construction of intersection PDA)
    - set difference with reg language
NOT closure: intersection of CFLs, complement of a CFL, set difference of CFLs
Complexity of conversions, just knowing polynomial or exponential time
Test for emptiness of CFL (informal description)
CYK algorithm
Undecidable problems for a CFL (DA SAPERE????)
## Turing Machines (COntrolla syllabus)
Def of TM
Def of ID for a TM 
Def of computation (and transitive closure) for a TM 
Accepting computation for a TM













