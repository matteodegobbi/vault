#crtp 
![[pages.excalidraw|800]]
Virtual memory is a concept used by most OSes that makes is so the addresses used by programs do not correspond with physical addresses.

To be able to do this we need something to perform an address translation when accessing the physical memory

The address translation is performed by the MMU (Memory Management Unit), 
A virtual address of N bits is split like this:
- the N-K MSBs of the virtual address are used as an index in the Page Table
- the K LSBs of the virtual address are used as a page offset
![[Pasted image 20241018140232.png]]

The Page Table is an array of numbers each L bits long, it contains physical addresses of pages corresponding to the virtual pages.

OS and MMU [share](https://stackoverflow.com/questions/58995151/why-does-the-os-need-a-page-table-if-the-mmu-already-has-one) the page tables

Each process has its page table, independent from other processes, this is important for when we will talk about [[Processes]] context switch.
## Reasons for virtual memory
One simple reason is that if we have two processes running the same program in one computer we want the two processes to not interfere with each other by using the same memory. Virtual memory allows this since the virtual addresses in different processes will be mapped to different physical addresses by the MMU.

Another reason is that virtual memory makes it so a process with a memory error will not corrupt memory used by other processes, this is good for both stability and security.

(Also have a program with more memory than available physical RAM, and make some pages only accessible in Kernel mode)

In any case memory access bugs that are still inside the page of the process will NOT be detected and stopped by the OS.
# Shared memory
We can still share memory across processes when using virtual memory. 
To do this we can use the OS (always OS, it cannot be done in user space) to make the address translation for two addresses in two processes point to the same physical memory.
Share memory is a type of IPC (Inter Processor Communication).
## Memory swapping
In Page Table entries we can also store additional information such as protection bits that define if the page is accessible in User mode. 
(In case an illegal page is accessed, an exception is generated by the MMU hardware itself)

We can also use memory swapping to be able to use more RAM than physically available. Basically we add a bit in the Page Table entry signifying whether the page is in memory or not. If the PTE is in memory the entry will contain the physical memory address of the page, otherwise it will contain the disk address of the page, to be able to go and fetch it from disk.

If a process tries to access a page not in memory the MMU will issue a Page Fault Exception, which does not indicate an error condition but it triggers an OS sequence of actions to recover the Page correctly:
* The current process is suspended (saving context etc, like with interrupts)
* A free page in memory is retrieved (if there's one otherwise replacement is needed)
* An I/O operation (DMA read) is started for copying the page from the disk into the memory page
* The PTE content is updated to reflect the new configuration
 * The suspended process is made ready again
 
 When the number of free memory pages goes under a given threshold, a swapping action begins in order to copy one or more memory page into the corresponding disk blocks. (Not in the course, but there are multiple page replacement algorithms that employ similar ideas to cache replacement)

 TODO Physical < virtual


Pages are contiguous both in physical and in virtual memory:
A page is the smallest unit of memory that the hardware page mapping function of the CPU deals with. If for example, pages are 4096 bytes in size, then each page begins and ends on a boundary aligned to 4096 bytes in both physical and virtual memory and all 4096 bytes in the page are mapped linearly and contiguously from virtual address to physical address within the page. Only at page boundaries can the mapping "jump around".